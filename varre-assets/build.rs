use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use regex::Regex;
use russimp::scene::{PostProcess, Scene};

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();

    process_shaders(&out_dir);
    process_models(&out_dir);
}

fn process_shaders(out_dir: &str) {
    let shader_dir = Path::new("shaders");
    let out_shader_dir = Path::new(out_dir).join("shaders");

    // Create output directory
    fs::create_dir_all(&out_shader_dir).expect("Failed to create output shader directory");

    // Tell cargo to rerun if shaders change or if the compiler path changes
    println!("cargo:rerun-if-changed=shaders");
    println!("cargo:rerun-if-env-changed=SLANGC_PATH");

    if !shader_dir.exists() {
        return;
    }

    // Determine which slangc to use:
    // 1. Check SLANGC_PATH environment variable
    // 2. Fallback to "slangc" (looking in system PATH)
    let slangc_command = env::var("SLANGC_PATH")
        .map(PathBuf::from)
        .unwrap_or_else(|_| PathBuf::from("slangc"));

    // Find all .slang files
    let slang_files: Vec<_> = fs::read_dir(shader_dir)
        .expect("Failed to read shaders directory")
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.extension()? == "slang" {
                Some(path)
            } else {
                None
            }
        })
        .collect();

    // Regex to match [shader("stage")] followed by a function definition
    let shader_attr_regex = Regex::new(r#"\[shader\("([^"]+)"\)\]\s*\n?\s*(?:[\w<>,\s]+)\s+(\w+)\s*\("#)
        .expect("Invalid regex");

    for shader_path in slang_files {
        let file_name = shader_path.file_name().unwrap().to_str().unwrap();
        let base_name = shader_path.file_stem().unwrap().to_str().unwrap();

        // Read the shader file to detect entry points
        let shader_content = fs::read_to_string(&shader_path)
            .expect(&format!("Failed to read shader file: {}", file_name));

        // Extract all shader entry points with their stages
        let mut entry_points = Vec::new();
        for cap in shader_attr_regex.captures_iter(&shader_content) {
            let stage_name = cap.get(1).unwrap().as_str();
            let function_name = cap.get(2).unwrap().as_str();
            entry_points.push((function_name.to_string(), stage_name.to_string()));
        }

        if entry_points.is_empty() {
            println!("cargo:warning=No shader entry points found in {}", file_name);
            continue;
        }

        println!("cargo:warning=Found {} entry point(s) in {}", entry_points.len(), file_name);

        for (entry_point, stage_name) in entry_points {
            // Replace hyphens with underscores for the output filename
            let safe_base_name = base_name.replace('-', "_");
            let output_path = out_shader_dir.join(format!("{}.{}.spv", safe_base_name, stage_name));

            println!("cargo:warning=Compiling shader: {} (entry: {}, stage: {})",
                     file_name, entry_point, stage_name);

            let status = Command::new(&slangc_command)
                .arg(&shader_path)
                .arg("-target")
                .arg("spirv")
                .arg("-entry")
                .arg(&entry_point)
                .arg("-o")
                .arg(&output_path)
                .status();

            match status {
                Ok(s) if s.success() => {
                    println!("cargo:warning=Successfully compiled {} ({})", file_name, entry_point);
                }
                Ok(s) => {
                    panic!("Failed to compile shader {} (entry {}): exit code {:?}",
                           file_name, entry_point, s.code());
                }
                Err(e) => {
                    let error_msg = if e.kind() == std::io::ErrorKind::NotFound {
                        format!(
                            "Executable '{:?}' not found. \n\
                            Please install slangc and ensure it's in your PATH, \n\
                            or set the SLANGC_PATH environment variable to the full path of the binary.",
                            slangc_command
                        )
                    } else {
                        format!("Failed to run slangc: {}", e)
                    };
                    panic!("Failed to run slangc for {} (entry {}): {}", file_name, entry_point, error_msg);
                }
            }
        }

        generate_shader_module(out_dir, &out_shader_dir);
    }
}

fn generate_shader_module(out_dir: &str, out_shader_dir: &Path) {
    let mut generated_code = String::from("// Generated by build.rs\n\npub mod shaders {\n");

    // Iterate over the actual .spv files produced in the output directory
    let entries = fs::read_dir(out_shader_dir).expect("Failed to read output shader directory");

    for entry in entries {
        let path = entry.expect("Failed to read entry").path();
        if path.extension().map_or(false, |ext| ext == "spv") {
            let file_name = path.file_name().unwrap().to_str().unwrap();

            // Transform "name.stage.spv" into a valid Rust identifier "NAME_STAGE"
            // We replace both dots and hyphens with underscores
            let var_name = file_name
                .replace(".spv", "")
                .replace('.', "_")
                .replace('-', "_")
                .to_uppercase();

            // We use a path relative to OUT_DIR for the include_bytes! macro
            let rel_path = format!("shaders/{}", file_name);

            generated_code.push_str(&format!(
                "    pub const {}: &[u8] = ::include_bytes_aligned::include_bytes_aligned!(4, concat!(env!(\"OUT_DIR\"), \"/{}\"));\n",
                var_name, rel_path
            ));
        }
    }

    generated_code.push_str("}\n");

    let dest_path = Path::new(out_dir).join("shaders.rs");
    fs::write(dest_path, generated_code).expect("Failed to write generated shaders.rs");
}

fn process_models(out_dir: &str) {
    let models_dir = Path::new("models");

    // Tell cargo to rerun if models change
    println!("cargo:rerun-if-changed=models");

    if !models_dir.exists() {
        return;
    }

    // Find all .obj files
    let obj_files: Vec<_> = fs::read_dir(models_dir)
        .expect("Failed to read models directory")
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.extension()? == "obj" {
                Some(path)
            } else {
                None
            }
        })
        .collect();

    if obj_files.is_empty() {
        return;
    }

    let mut models_code = String::from("// Generated by build.rs\n\n");
    models_code.push_str("use glam::Vec3;\n\n");
    models_code.push_str("#[derive(Debug, Clone)]\n");
    models_code.push_str("pub struct Model {\n");
    models_code.push_str("    pub verts: Vec<Vec3>,\n");
    models_code.push_str("    pub indices: Vec<u32>,\n");
    models_code.push_str("    pub uvs: Vec<f32>,\n");
    models_code.push_str("}\n\n");
    models_code.push_str("pub mod models {\n");
    models_code.push_str("    use super::Model;\n");
    models_code.push_str("    use glam::Vec3;\n\n");

    for model_path in obj_files {
        let file_name = model_path.file_name().unwrap().to_str().unwrap();
        let base_name = model_path.file_stem().unwrap().to_str().unwrap();

        println!("cargo:warning=Loading model: {}", file_name);

        // Load the model using russimp
        let scene = Scene::from_file(
            model_path.to_str().unwrap(),
            vec![
                PostProcess::Triangulate,
                PostProcess::JoinIdenticalVertices,
                PostProcess::GenerateNormals,
            ],
        ).expect(&format!("Failed to load model: {}", file_name));

        // Extract vertices, indices, and UVs from the first mesh
        if scene.meshes.is_empty() {
            println!("cargo:warning=No meshes found in {}", file_name);
            continue;
        }

        let mesh = &scene.meshes[0];

        // Convert vertices to Vec3
        let mut verts = Vec::new();
        for vertex in &mesh.vertices {
            verts.push(format!("Vec3::new({}, {}, {})", vertex.x, vertex.y, vertex.z));
        }

        // Flatten indices
        let mut indices = Vec::new();
        for face in &mesh.faces {
            for index in &face.0 {
                indices.push(*index);
            }
        }

        // Flatten UVs (u, v for each vertex)
        let mut uvs = Vec::new();
        if !mesh.texture_coords.is_empty() && mesh.texture_coords[0].is_some() {
            if let Some(tex_coords) = &mesh.texture_coords[0] {
                for uv in tex_coords {
                    uvs.push(uv.x);
                    uvs.push(uv.y);
                }
            }
        }

        // Generate a valid Rust identifier
        let var_name = base_name
            .replace('-', "_")
            .replace('.', "_")
            .to_uppercase();

        // Write the model as a constant
        models_code.push_str(&format!(
            "    pub const {}: Model = Model {{\n",
            var_name
        ));
        models_code.push_str("        verts: vec![");
        for (i, vert) in verts.iter().enumerate() {
            if i > 0 {
                models_code.push_str(", ");
            }
            models_code.push_str(vert);
        }
        models_code.push_str("],\n");
        models_code.push_str(&format!("        indices: vec!{:?},\n", indices));
        models_code.push_str(&format!("        uvs: vec!{:?},\n", uvs));
        models_code.push_str("    };\n\n");

        println!("cargo:warning=Loaded model {} with {} vertices, {} indices",
                 file_name, mesh.vertices.len(), indices.len());
    }

    models_code.push_str("}\n");

    let dest_path = Path::new(out_dir).join("models.rs");
    fs::write(dest_path, models_code).expect("Failed to write generated models.rs");
}
