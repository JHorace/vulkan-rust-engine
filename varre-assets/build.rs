use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use regex::Regex;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let shader_dir = Path::new("shaders");
    let out_shader_dir = Path::new(&out_dir).join("shaders");

    // Create output directory
    fs::create_dir_all(&out_shader_dir).expect("Failed to create output shader directory");

    // Tell cargo to rerun if shaders change or if the compiler path changes
    println!("cargo:rerun-if-changed=shaders");
    println!("cargo:rerun-if-env-changed=SLANGC_PATH");

    if !shader_dir.exists() {
        return;
    }

    // Determine which slangc to use:
    // 1. Check SLANGC_PATH environment variable
    // 2. Fallback to "slangc" (looking in system PATH)
    let slangc_command = env::var("SLANGC_PATH")
        .map(PathBuf::from)
        .unwrap_or_else(|_| PathBuf::from("slangc"));

    // Find all .slang files
    let slang_files: Vec<_> = fs::read_dir(shader_dir)
        .expect("Failed to read shaders directory")
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.extension()? == "slang" {
                Some(path)
            } else {
                None
            }
        })
        .collect();

    // Regex to match [shader("stage")] followed by a function definition
    let shader_attr_regex = Regex::new(r#"\[shader\("([^"]+)"\)\]\s*\n?\s*(?:[\w<>,\s]+)\s+(\w+)\s*\("#)
        .expect("Invalid regex");

    for shader_path in slang_files {
        let file_name = shader_path.file_name().unwrap().to_str().unwrap();
        let base_name = shader_path.file_stem().unwrap().to_str().unwrap();

        // Read the shader file to detect entry points
        let shader_content = fs::read_to_string(&shader_path)
            .expect(&format!("Failed to read shader file: {}", file_name));

        // Extract all shader entry points with their stages
        let mut entry_points = Vec::new();
        for cap in shader_attr_regex.captures_iter(&shader_content) {
            let stage_name = cap.get(1).unwrap().as_str();
            let function_name = cap.get(2).unwrap().as_str();
            entry_points.push((function_name.to_string(), stage_name.to_string()));
        }

        if entry_points.is_empty() {
            println!("cargo:warning=No shader entry points found in {}", file_name);
            continue;
        }

        println!("cargo:warning=Found {} entry point(s) in {}", entry_points.len(), file_name);

        for (entry_point, stage_name) in entry_points {
            // Replace hyphens with underscores for the output filename
            let safe_base_name = base_name.replace('-', "_");
            let output_path = out_shader_dir.join(format!("{}.{}.spv", safe_base_name, stage_name));

            println!("cargo:warning=Compiling shader: {} (entry: {}, stage: {})",
                     file_name, entry_point, stage_name);

            let status = Command::new(&slangc_command)
                .arg(&shader_path)
                .arg("-target")
                .arg("spirv")
                .arg("-entry")
                .arg(&entry_point)
                .arg("-o")
                .arg(&output_path)
                .status();

            match status {
                Ok(s) if s.success() => {
                    println!("cargo:warning=Successfully compiled {} ({})", file_name, entry_point);
                }
                Ok(s) => {
                    panic!("Failed to compile shader {} (entry {}): exit code {:?}",
                           file_name, entry_point, s.code());
                }
                Err(e) => {
                    let error_msg = if e.kind() == std::io::ErrorKind::NotFound {
                        format!(
                            "Executable '{:?}' not found. \n\
                            Please install slangc and ensure it's in your PATH, \n\
                            or set the SLANGC_PATH environment variable to the full path of the binary.",
                            slangc_command
                        )
                    } else {
                        format!("Failed to run slangc: {}", e)
                    };
                    panic!("Failed to run slangc for {} (entry {}): {}", file_name, entry_point, error_msg);
                }
            }
        }

        generate_shader_module(&out_dir, &out_shader_dir);
    }
}

fn generate_shader_module(out_dir: &str, out_shader_dir: &Path) {
    let mut generated_code = String::from("// Generated by build.rs\n\npub mod shaders {\n");

    // Iterate over the actual .spv files produced in the output directory
    let entries = fs::read_dir(out_shader_dir).expect("Failed to read output shader directory");

    for entry in entries {
        let path = entry.expect("Failed to read entry").path();
        if path.extension().map_or(false, |ext| ext == "spv") {
            let file_name = path.file_name().unwrap().to_str().unwrap();

            // Transform "name.stage.spv" into a valid Rust identifier "NAME_STAGE"
            // We replace both dots and hyphens with underscores
            let var_name = file_name
                .replace(".spv", "")
                .replace('.', "_")
                .replace('-', "_")
                .to_uppercase();

            // We use a path relative to OUT_DIR for the include_bytes! macro
            let rel_path = format!("shaders/{}", file_name);

            generated_code.push_str(&format!(
                "    pub const {}: &[u8] = ::include_bytes_aligned::include_bytes_aligned!(4, concat!(env!(\"OUT_DIR\"), \"/{}\"));\n",
                var_name, rel_path
            ));
        }
    }

    generated_code.push_str("}\n");

    let dest_path = Path::new(out_dir).join("shaders.rs");
    fs::write(dest_path, generated_code).expect("Failed to write generated shaders.rs");
}
